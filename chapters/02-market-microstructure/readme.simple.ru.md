# Глава 2: Как устроена биржа изнутри (простым языком)

## Для кого эта глава?

Эта глава написана так, чтобы её мог понять школьник. Мы будем использовать примеры из обычной жизни, а не сложную математику.

---

## Что такое биржа?

Представь **школьный базар**, где ребята обмениваются коллекционными карточками.

- Петя хочет **продать** редкую карточку за 100 рублей
- Маша хочет **купить** такую карточку, но готова заплатить только 90 рублей

Между ними разница в 10 рублей — это называется **спред** (spread).

Биржа — это как огромный организованный базар, где вместо карточек торгуют акциями, валютой, криптовалютой.

---

## Книга ордеров (Order Book) — очередь желающих

### Представь очередь в столовой

В столовой есть **две очереди**:
- Очередь **покупателей** пирожков (те, кто хочет купить)
- Очередь **продавцов** (тётя-повар с пирожками)

```
ПРОДАВЦЫ (хотят продать):
┌─────────────────────────┐
│ Пирожок за 50 руб - 3шт │  ← Самая дешёвая цена
│ Пирожок за 55 руб - 5шт │
│ Пирожок за 60 руб - 2шт │
└─────────────────────────┘

═══════════════════════════  Разница = 5 руб (спред)

ПОКУПАТЕЛИ (хотят купить):
┌─────────────────────────┐
│ Готов дать 45 руб - Вася│  ← Самая высокая цена покупки
│ Готов дать 40 руб - Петя│
│ Готов дать 35 руб - Маша│
└─────────────────────────┘
```

### Как происходит сделка?

Если **Коля** приходит и говорит: "Хочу пирожок **прямо сейчас** за любую цену!" — он покупает за 50 руб (самая дешёвая цена продажи).

Если **Аня** приходит и говорит: "Продаю пирожок **прямо сейчас** за любую цену!" — она продаёт за 45 руб (самая высокая цена покупки).

---

## Типы заявок — как попросить пирожок

### 1. Лимитный ордер (Limit Order)
**"Хочу купить, но только за эту цену!"**

Пример из жизни: "Куплю iPhone, но только за 50 000 руб, не дороже. Буду ждать, пока кто-то согласится."

```rust
// Лимитный ордер на покупку
struct LimitOrder {
    price: 50000,      // Цена, которую готов заплатить
    quantity: 1,       // Количество
    side: "Покупка",   // Покупаю
}
```

### 2. Рыночный ордер (Market Order)
**"Хочу купить ПРЯМО СЕЙЧАС за любую цену!"**

Пример из жизни: "Мне очень нужен зонтик, на улице дождь! Заплачу сколько скажете, только дайте быстрее!"

```rust
// Рыночный ордер на покупку
struct MarketOrder {
    quantity: 1,       // Количество
    side: "Покупка",   // Покупаю
    // Цены нет! Купит по первой доступной цене
}
```

---

## Кто такой маркетмейкер?

### Аналогия: киоск с газировкой

Представь **киоск**, который покупает газировку оптом за 40 руб и продаёт по 50 руб.

- Киоск **всегда готов купить** (если у тебя есть газировка)
- Киоск **всегда готов продать** (если тебе нужна газировка)
- Разница 10 руб — это его **заработок** (спред)

**Маркетмейкер на бирже делает то же самое:**
- Выставляет заявку на покупку по низкой цене
- Выставляет заявку на продажу по высокой цене
- Зарабатывает на разнице

```rust
// Маркетмейкер выставляет две заявки
fn make_quotes(current_price: f64) -> (f64, f64) {
    let bid = current_price - 0.5;  // Готов купить дешевле
    let ask = current_price + 0.5;  // Готов продать дороже
    (bid, ask)
}

// Пример: цена сейчас 100
// Маркетмейкер: "Куплю за 99.5, продам за 100.5"
```

### Проблема маркетмейкера: "застрял с товаром"

Представь, что ты киоск с газировкой:
- Утром купил 100 бутылок по 40 руб
- Вдруг все перестали пить газировку!
- У тебя 100 бутылок, которые никто не покупает
- А цена на рынке упала до 30 руб

**Ты в минусе!** Это называется **inventory risk** (риск товарных запасов).

---

## Процесс Хоукса — почему события идут "пачками"

### Пример: аплодисменты в театре

В театре:
1. Один человек начал хлопать
2. Сосед услышал и тоже захлопал
3. Потом ещё несколько человек
4. Через секунду хлопает весь зал!

Один хлопок **вызвал** волну новых хлопков.

### На бирже то же самое:

1. Кто-то купил 1000 акций
2. Это увидели другие: "О, кто-то покупает! Надо тоже купить!"
3. Начинается волна покупок
4. Цена растёт

**Процесс Хоукса** — это математический способ описать такие "цепные реакции".

```rust
// Простой пример: интенсивность событий
struct HawkesProcess {
    base_rate: f64,     // Базовая скорость событий (1 в минуту)
    excitation: f64,    // Насколько одно событие ускоряет следующие
    decay: f64,         // Как быстро эффект затухает
}

impl HawkesProcess {
    // После каждого события вероятность нового растёт
    fn event_happened(&mut self) {
        // Интенсивность временно увеличивается
        // Потом постепенно возвращается к норме
    }
}
```

### Визуально:

```
Интенсивность событий:

    ^
    │     /\        /\
    │    /  \      /  \    /\
    │   /    \    /    \  /  \
────┴──/──────\──/──────\/────\───> Время
       ↑       ↑         ↑
    Событие Событие   Событие
```

Каждое событие создаёт "пик", который потом затухает.

---

## Модель Avellaneda-Stoikov: умный киоск

### Задача

Ты держишь киоск и хочешь заработать, но не хочешь "застрять с товаром".

### Решение: сдвигай цены!

**Если у тебя слишком много товара:**
- Продавай ДЕШЕВЛЕ (чтобы быстрее избавиться)
- Покупай ДОРОЖЕ (чтобы меньше докупать)

**Если товара мало:**
- Продавай ДОРОЖЕ (не торопишься продавать)
- Покупай ДЕШЕВЛЕ (хочешь купить побольше)

### В коде:

```rust
struct SmartMarketMaker {
    inventory: i32,     // Сколько товара у нас
    risk_level: f64,    // Насколько боимся риска (0.1 = смелый, 1.0 = осторожный)
}

impl SmartMarketMaker {
    fn calculate_prices(&self, market_price: f64) -> (f64, f64) {
        // Сдвигаем "справедливую" цену в зависимости от inventory
        let adjusted_price = market_price
            - (self.inventory as f64) * self.risk_level;

        // Если inventory = +10, adjusted_price ниже рыночной
        // Это значит мы хотим продать!

        // Если inventory = -10, adjusted_price выше рыночной
        // Это значит мы хотим купить!

        let spread = 1.0;  // Наш заработок
        let bid = adjusted_price - spread / 2.0;
        let ask = adjusted_price + spread / 2.0;

        (bid, ask)
    }
}

fn main() {
    let mut mm = SmartMarketMaker {
        inventory: 0,
        risk_level: 0.1,
    };

    let market_price = 100.0;

    // Нет товара - цены симметричны
    println!("{:?}", mm.calculate_prices(market_price));
    // Выведет: (99.5, 100.5)

    // Накопилось 10 единиц товара
    mm.inventory = 10;
    println!("{:?}", mm.calculate_prices(market_price));
    // Выведет: (98.5, 99.5) - готовы продать дешевле!

    // У нас долг -10 единиц
    mm.inventory = -10;
    println!("{:?}", mm.calculate_prices(market_price));
    // Выведет: (100.5, 101.5) - готовы купить дороже!
}
```

---

## Почему важен баланс в книге ордеров?

### Аналогия: качели

```
         Покупатели           Продавцы
             ↓                   ↓
        ┌────┴────┐         ┌────┴────┐
        │ 100 шт  │         │  50 шт  │
        └─────────┘         └─────────┘
              \               /
               \             /
                \     △     /
                 \   / \   /
                  \_/   \_/

        Качели наклонены влево - цена пойдёт ВВЕРХ
```

- Если **покупателей больше** — цена скорее вырастет
- Если **продавцов больше** — цена скорее упадёт

### В коде:

```rust
fn predict_price_direction(bid_volume: u64, ask_volume: u64) -> &'static str {
    let total = bid_volume + ask_volume;
    let imbalance = (bid_volume as f64 - ask_volume as f64) / total as f64;

    // imbalance от -1 до +1
    // +1 = все покупатели
    // -1 = все продавцы

    if imbalance > 0.3 {
        "Скорее всего цена ВЫРАСТЕТ"
    } else if imbalance < -0.3 {
        "Скорее всего цена УПАДЁТ"
    } else {
        "Непонятно, примерно поровну"
    }
}
```

---

## Microprice — более точная "средняя" цена

### Проблема с обычной средней ценой

Bid = 99, Ask = 101
Обычная средняя = (99 + 101) / 2 = 100

Но что если:
- На Bid стоит 1000 лотов
- На Ask стоит только 10 лотов

Скорее всего цена пойдёт ВВЕРХ (продавцов мало), значит "честная" цена ближе к 101!

### Microprice учитывает объёмы:

```rust
fn microprice(bid: f64, ask: f64, bid_volume: f64, ask_volume: f64) -> f64 {
    // Взвешенная средняя
    // Больший объём "перетягивает" цену к себе
    (bid_volume * ask + ask_volume * bid) / (bid_volume + ask_volume)
}

fn main() {
    let bid = 99.0;
    let ask = 101.0;

    // Равные объёмы
    let mp1 = microprice(bid, ask, 100.0, 100.0);
    println!("Равные объёмы: {}", mp1);  // 100.0

    // Покупателей больше
    let mp2 = microprice(bid, ask, 1000.0, 10.0);
    println!("Покупателей больше: {}", mp2);  // 99.02 (ближе к bid)

    // Продавцов больше
    let mp3 = microprice(bid, ask, 10.0, 1000.0);
    println!("Продавцов больше: {}", mp3);  // 100.98 (ближе к ask)
}
```

---

## Практический пример: простой симулятор

Давай сделаем простую игру-симулятор биржи:

```rust
use rand::Rng;

// Книга ордеров (очень упрощённая)
struct SimpleOrderBook {
    best_bid: f64,       // Лучшая цена покупки
    best_ask: f64,       // Лучшая цена продажи
    bid_volume: u64,     // Объём на bid
    ask_volume: u64,     // Объём на ask
}

impl SimpleOrderBook {
    fn new(mid_price: f64) -> Self {
        Self {
            best_bid: mid_price - 0.5,
            best_ask: mid_price + 0.5,
            bid_volume: 100,
            ask_volume: 100,
        }
    }

    fn mid_price(&self) -> f64 {
        (self.best_bid + self.best_ask) / 2.0
    }

    fn spread(&self) -> f64 {
        self.best_ask - self.best_bid
    }

    // Симулируем случайный ордер
    fn random_order(&mut self) {
        let mut rng = rand::thread_rng();

        // С вероятностью 50% покупка или продажа
        if rng.gen_bool(0.5) {
            // Кто-то КУПИЛ по рынку
            // Это "съедает" объём на ask
            self.ask_volume = self.ask_volume.saturating_sub(10);

            // Если объём закончился, цена растёт
            if self.ask_volume == 0 {
                self.best_bid += 1.0;
                self.best_ask += 1.0;
                self.ask_volume = 100;
                self.bid_volume = 100;
            }
        } else {
            // Кто-то ПРОДАЛ по рынку
            self.bid_volume = self.bid_volume.saturating_sub(10);

            if self.bid_volume == 0 {
                self.best_bid -= 1.0;
                self.best_ask -= 1.0;
                self.ask_volume = 100;
                self.bid_volume = 100;
            }
        }
    }
}

// Простой маркетмейкер
struct SimpleMarketMaker {
    inventory: i32,
    cash: f64,
    pnl_history: Vec<f64>,
}

impl SimpleMarketMaker {
    fn new() -> Self {
        Self {
            inventory: 0,
            cash: 10000.0,
            pnl_history: Vec::new(),
        }
    }

    // Рассчитать текущую прибыль
    fn pnl(&self, current_price: f64) -> f64 {
        self.cash + (self.inventory as f64) * current_price - 10000.0
    }

    // Принять решение о котировках
    fn decide(&mut self, book: &SimpleOrderBook) -> (f64, f64) {
        let mid = book.mid_price();

        // Простая стратегия: сдвигаем цены от inventory
        let shift = (self.inventory as f64) * 0.1;

        let my_bid = mid - 0.5 - shift;
        let my_ask = mid + 0.5 - shift;

        (my_bid, my_ask)
    }

    // Если наш ордер исполнился
    fn on_fill(&mut self, side: &str, price: f64, volume: i32) {
        match side {
            "buy" => {
                self.inventory += volume;
                self.cash -= price * (volume as f64);
            }
            "sell" => {
                self.inventory -= volume;
                self.cash += price * (volume as f64);
            }
            _ => {}
        }
    }
}

fn main() {
    let mut book = SimpleOrderBook::new(100.0);
    let mut mm = SimpleMarketMaker::new();

    println!("Начинаем симуляцию!");
    println!("Начальный капитал: {} руб", mm.cash);
    println!();

    // Симулируем 20 шагов
    for step in 1..=20 {
        // Случайное изменение рынка
        book.random_order();

        // Маркетмейкер решает, какие цены выставить
        let (my_bid, my_ask) = mm.decide(&book);

        // Простая логика исполнения:
        // Если наш bid >= best_ask рынка, мы покупаем
        // Если наш ask <= best_bid рынка, мы продаём

        if my_bid >= book.best_ask {
            mm.on_fill("buy", book.best_ask, 1);
            println!("Шаг {}: КУПИЛИ по {:.2}", step, book.best_ask);
        }

        if my_ask <= book.best_bid {
            mm.on_fill("sell", book.best_bid, 1);
            println!("Шаг {}: ПРОДАЛИ по {:.2}", step, book.best_bid);
        }

        let pnl = mm.pnl(book.mid_price());
        println!(
            "Шаг {}: Цена={:.2}, Инвентарь={}, P&L={:.2}",
            step, book.mid_price(), mm.inventory, pnl
        );
    }

    println!();
    println!("=== Итоги ===");
    println!("Финальный инвентарь: {}", mm.inventory);
    println!("Финальный P&L: {:.2} руб", mm.pnl(book.mid_price()));
}
```

---

## Главные идеи главы (запомни это!)

### 1. Книга ордеров — это две очереди
- Покупатели (bids) хотят купить подешевле
- Продавцы (asks) хотят продать подороже
- Сделка происходит, когда цены пересекаются

### 2. Маркетмейкер зарабатывает на спреде
- Покупает дешевле, продаёт дороже
- Но рискует "застрять с товаром"

### 3. События на рынке идут "волнами"
- Одна покупка провоцирует другие
- Это описывается процессом Хоукса

### 4. Баланс объёмов предсказывает движение цены
- Больше покупателей — цена вверх
- Больше продавцов — цена вниз

### 5. Умный маркетмейкер сдвигает цены
- Много товара? Продавай дешевле!
- Мало товара? Покупай дешевле!

---

## Домашнее задание

### Задание 1: Нарисуй книгу ордеров
Нарисуй на бумаге книгу ордеров для своей любимой игры/карточек. Укажи:
- 3 уровня цен покупателей
- 3 уровня цен продавцов
- Спред

### Задание 2: Сыграй в маркетмейкера
Попроси друга или родителей сыграть в игру:
1. Вы торгуете конфетами
2. Ты — маркетмейкер: называешь цену покупки и продажи
3. Друг — случайный покупатель/продавец
4. Посмотри, получится ли заработать!

### Задание 3: Запусти симулятор
Если умеешь программировать:
1. Скопируй код симулятора выше
2. Запусти его несколько раз
3. Попробуй изменить параметры (shift) и посмотри, как меняется P&L

---

## Словарик

| Термин | Простое объяснение |
|--------|-------------------|
| **Order Book** | Список всех заявок на покупку и продажу |
| **Bid** | Цена, по которой кто-то хочет КУПИТЬ |
| **Ask** | Цена, по которой кто-то хочет ПРОДАТЬ |
| **Spread** | Разница между лучшей ценой продажи и покупки |
| **Market Maker** | Тот, кто выставляет заявки на покупку И продажу |
| **Inventory** | Сколько товара у тебя сейчас есть |
| **P&L** | Profit and Loss — прибыль или убыток |
| **Hawkes Process** | Математика для "цепных реакций" событий |
| **Microprice** | Более точная средняя цена с учётом объёмов |

---

*Теперь ты знаешь, как работает биржа изнутри! В следующих главах мы научимся строить портфели и предсказывать цены.*
